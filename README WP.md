[# Шаблон backend сервера на Golang — часть 5 - Worker pool](https://habr.com/ru/post/720286/)

[//]: # (![Схема развертывания в Kubernetes]&#40;https://github.com/romapres2010/goapp/raw/master/doc/diagram/APP%20-%20Kebernates.jpg&#41;)

[Первая часть](https://habr.com/ru/post/492062/) шаблона была посвящена HTTP серверу.

[Вторая часть](https://habr.com/ru/post/500554/) шаблона была посвящена прототипированию REST API.

[Третья часть](https://habr.com/ru/post/716634/) посвящена развертыванию шаблона в Docker, Docker Compose, Kubernetes (kustomize).

Четвертая часть будет посвящена развертыванию в Kubernetes с Helm chart и настройке Horizontal Autoscaler.

[Пятая часть](https://habr.com/ru/post/720286/) посвящена простому Worker pool.

При развертывании приложения в Kubernetes столкнулись с особенностями.
- при росте нагрузки Horizontal Autoscaler (HA) может создавать новые Pod c приложением и перенаправлять на него часть запросов.
- при снижении нагрузки (по памяти или загрузке процессора), Horizontal Autoscaler останавливает Pod c приложением.   

В нашем приложении Worker pool, использовался для двух типов задач: 
- высоконагруженных расчетов с периодической нагрузкой
- длительных (1-30 сек) и слабонагруженных задач взаимодействия с внешними сервисами   

В периоды высокой нагрузки, Horizontal Autoscaler создавал 2-5 новых Pod, а через 30-60 минут удалял ненужные. Pod останавливаются произвольным образом, в результате мы получали обрывы соединений и отказ в обслуживании для длительных операции. 

Правильный вариант решения такой проблемы - это разнесение разных типов задач на разные микросервисы. Но вместе с этим, пришлось серьезно перепроектировать Worker pool.

Представленный в шаблоне Worker pool реализует следующую функциональность:
- Возможность экстренной остановки Worker pool в целом 
  - явно по команде остановки
  - автоматически по закрытию корневого контекста
  - контроль timeout остановки работающих worker
- Возможность экстренной остановки отдельного worker
  - явно по команде остановки (жесткий режим или с ожиданием завершения текущей task)
  - автоматически по закрытию корневого контекста
- Возможность экстренной остановки отдельного task
  - явно по команде остановки
  - по предельному таймауту
- Автоматический перезапуск сбойного worker
- Сбор метрик [prometheus](https://prometheus.io/) по загрузке worker, очереди задач и производительности выполнения по типам task
- Возможность управления группами task в рамках единого Worker pool
- Накладные расходы Worker pool для одной task 500-900 ns/op 60 B/op 2 allocs/op

Ссылка на [репозиторий проекта](https://github.com/romapres2010/goapp).

Шаблон goapp в репозитории полностью готов к развертыванию в Docker, Docker Compose, Kubernetes (kustomize), Kubernetes (helm).

## Содержание
1. Архитектура Worker pool
2. 
3. Оптимизация накладных расходов Worker pool
4. Нагрузочное тестирование
 
<cut />

## . Архитектура Worker pool
В основе лежит концепция из статьи [Ahad Hasan](https://hackernoon.com/concurrency-in-golang-and-workerpool-part-2-l3w31q7). 

